/*
Copywrite 2013, 4thTemple.com, FourthTemple.org.

the idea with this handler is to manage the global location settings
at very least, bounding boxes need to be mantained from the graphics side
*/


function withinRect(point, rect) {
//	console.log("pointx:"+point.x+" pointy:"+point.y+" rectx:"+rect.x+" recty"+rect.y+"rectb"+rect.bottom);
//	console.log("iswithin"+rect.right);
	//console.log((point.x >= rect.x) +" "+(point.x <=rect.right)+" "+(point.y >= rect.y)+" "+(point.y <= rect.bottom))
	return ( (point.x >= rect.x) && (point.x <=rect.right) && (point.y >= rect.y) && (point.y <= rect.bottom));
}

snapSpace = function() {
	this.setupHandlers();
//	if (!snapSpace.prototype.snapLookup) snapSpace.prototype.snapLookup = {}
	this.snapLookup = snapSpace.prototype.snapLookup; //enforce singleton
};
snapSpace.prototype = {
	"snapWidth":50,
	"snapHeight":50,
	"snapLookup": {}, // should be an outside object or a singleton referenced by snapSpace.prototype.snapLookup
	// item must have a 'getLabel()' object with x,y,width,height .. (perhaps rect is already used then we use smth else)
	// quantize objets to nearest grid snap point

	// the rects should be stored in some type of hash

	// get bounding box by looking at type
	// bounding box handler.. done
/*

	"getItems": function(po) {
		var ptr = po.ptr;
		//console.log(po);
		//switch (type) {
		//	case "index": 
		var a =  snapSpace.prototype.getLink(ptr, po.index);
		//	case "label": 
		var b =  snapSpace.prototype.getLabel(ptr);
		return {"links":a, "labels":b};
		//	}
	},

	"getLabel": function (ptr) {
		//console.log(ptr+"______________________________________");
		var id = ptr[0];
		var o = getObject(ptr, graphics);
		//console.log("_____--_____");
		//console.log(o);
	//	console.log("-----__-----");
		//console.log("cow cow cow cow");
		//console.log(o.gfx);
		var ox = o.gfx;
		//console.log(graphics[id]); 
		//console.log("cat cat cat");
		var loc = graphics[id].model.loc;
		var globalY = ox.y+loc.y+(ox.links*ox.linkHeight); // global y
		var globalX = ox.x+loc.x;
		return { "height":ox.rectHeight, "x":globalX, "y":globalY, "z":loc.z, "right":globalX+o.gfx.width, "bottom":o.gfx.rectHeight+globalY, "ptr":ptr, "type":"label" }
	},

	"getLink": function(ptr, i) {
		var id = ptr[0];
		var o = getObject(ptr, graphics);
		//console.log("cow cow cow cow");
		//console.log(o.gfx);
		var ox = o.gfx;
		var loc = graphics[id].model.loc;
		var nl = o.gfx.links;
		var a = [];
		// o.gfx.y is the local offset, loc.y is the global position of the object
	//	for (var i =0; i < nl; i++) {
		var globalX = o.gfx.x+loc.x;
		var globalY = o.gfx.y+loc.y;
		var y = globalY+(i*ox.linkHeight);
		var b = globalX+((i+1)*ox.linkHeight);
		var ro = { "height":ox.linkHeight, "x":globalX, "y":globalY, "z":loc.z, "right":o.gfx.x+o.gfx.linkHeight+loc.x, "bottom":globalY+ox.linkHeight, "ptr":ptr, "index":i, "type":"index"}
	//	a.push(ro)
	//	if (yi) 
		return ro
	//	}
	},
	"getLinks": function(ptr, yi) {
		var id = ptr[0];
		var o = getObject(ptr, graphics);
		//console.log("cow cow cow cow");
		//console.log(o.gfx);
		var ox = o.gfx;
		var loc = graphics[id].model.loc;
		var nl = o.gfx.links;
		var a = [];

		// o.gfx.y is the local offset, loc.y is the global position of the object
		for (var i =0; i < nl; i++) {
			//console.log("cat");
			var globalX = o.gfx.x+loc.x;
			var globalY = o.gfx.y+loc.y;
			var y = globalY+(i*ox.linkHeight);
			var b = globalX+((i+1)*ox.linkHeight);
			//console.log(ox);
			//console.log("ox cutta");
			var ro = { "height":ox.linkHeight, "x":globalX, "y":y, "z":loc.z, "right":o.gfx.x+o.gfx.width+loc.x, "bottom":y+ox.linkHeight, "ptr":ptr, "index":i, "type":"index"}
			a.push(ro)
			//console.log(ro);
			if (yi) 
				return ro
		}
		//console.log(a);
		return a;
	},
*/
	// expects a group (array) of objects' bounding boxes.........
	"regObject":function(ptr) { // using bounding box from the gfx renderer
		var ptr2 = copyArray(ptr);
		var o = getObject(ptr, graphics);
		console.log(ptr);
		console.log(o);
		snapLookup = snapSpace.prototype.snapLookup;
		var id = ptr[0];
		// should b able to copy and paste
		for (var i = 0; i < o.gfx.boundingBox.length; i++) {
			var box = o[i];
			var rect = o.gfx.boundingBox[i];
			//console.log(rect);
			//console.log("underground");
			console.log(rect);
			console.log("********")
			var leftMostX = Math.floor(rect.x/this.snapWidth) * this.snapWidth
				//		leftMostX + (units*n) = rightMostX
				//		var unitHeight = Math.ceil(rect.height/self.snapHeight);
			var topMostY = Math.floor(rect.y/this.snapHeight) * this.snapHeight;
			var snaps = [];	
			//	console.log(rect);
			//	console.log("+____+");
			//	console.log(item);
			// needs to also manage the links 
			for (var x = leftMostX; x <= rect.right; x += this.snapWidth) {

				if (snapLookup[x] === undefined)
					snapLookup[x] = [];
				//console.log("fuck..you");
				for (var y = topMostY; y <= rect.bottom; y += this.snapHeight) {

					if (!snapLookup[x][y])
						snapLookup[x][y] = {};
					//var idx = self.snapLookUp[x][y].length;
					//if (this.snapLookup[x][y][ptrsi] === undefined) 
					//	this.snapLookup[x][y][ptrsi] = [];
	
					snapLookup[x][y][rect.ptr.join()] = rect.ptr;//{"type":"index", "ptr":ptr, "index":i};
					/*
					   this.f = function(x,y,hash,snap) {
					   var self = this;
					   this.x = x, this.y = y, this.hash = hash, this.snap = snap;
					   this.cleanUp = function() {
					   delete snap[self.x][self.y][self.hash];
					   }
					   }
					 */
					//var hash = item.__hid
					var snap = {"ptr":ptr, "x":x, "y":y}; 
					// '['+x+']['+y+']['+idx+']';
					// console.log(snap + " <<<<<< snap");
					//alert("test...");
					snaps.push(snap);
				}
			}
			//console.log(snaps);
			if (!gfxLookup[id].snaps) gfxLookup[id].snaps = [];
			gfxLookup[id].snaps.push(snaps);
		}


		// sort through 'gfx' properties to get rects 
		

	},
/*
	"setLink":function(ptr) {
		// divide the box into components
		//console.log("cow cow cow cow");
		//console.log(ptr);
		var id = ptr[0];
		var rects = this.getLinks(ptr);
		snapLookup = snapSpace.prototype.snapLookup;
		//console.log(rects);
		//console.log("_________*&magic potion&&*___________"); 
//		return;
//		var unitWidth = Math.ceil(rect.width/self.snapWidth)
		var rl = rects.length;
		ptrs = ptr.join() + ",links"; 
		for (var i = 0; i < rl; i++) {
			var rect = rects[i];
			//console.log(rect);
			//console.log("underground");
			var leftMostX = Math.floor(rect.x/this.snapWidth) * this.snapWidth
				//		leftMostX + (units*n) = rightMostX
				//		var unitHeight = Math.ceil(rect.height/self.snapHeight);
			var topMostY = Math.floor(rect.y/this.snapHeight) * this.snapHeight;
			var snaps = [];	
			//	console.log(rect);
			//	console.log("+____+");
			//	console.log(item);
			// needs to also manage the links 
			ptrsi = ptrs + ","+i;
			for (var x = leftMostX; x <= rect.right; x += this.snapWidth) {

				if (snapLookup[x] === undefined)
					snapLookup[x] = [];
				//console.log("fuck..you");
				for (var y = topMostY; y <= rect.bottom; y += this.snapHeight) {

					if (!snapLookup[x][y])
						snapLookup[x][y] = {};
					//var idx = self.snapLookUp[x][y].length;
					//if (this.snapLookup[x][y][ptrsi] === undefined) 
					//	this.snapLookup[x][y][ptrsi] = [];
	
					snapLookup[x][y][ptrsi] = {"type":"index", "ptr":ptr, "index":i};
										//var hash = item.__hid
					var snap = {"ptr":ptrsi, "x":x, "y":y}; 
					// '['+x+']['+y+']['+idx+']';
					// console.log(snap + " <<<<<< snap");
					//alert("test...");
					snaps.push(snap);
				}
			}
			//console.log(snaps);
			if (!gfxLookup[id].snaps) gfxLookup[id].snaps = [];
			gfxLookup[id].snaps.push(snaps);
		}
	//	return snaps; // the mouseup controller should reset this on move	
	},


	"setLinks":function(ptr) {
		// divide the box into components
		//console.log("cow cow cow cow");
		//console.log(ptr);
		var id = ptr[0];
		var rects = this.getLinks(ptr);
		snapLookup = snapSpace.prototype.snapLookup;
		//console.log(rects);
		//console.log("_________*&magic potion&&*___________"); 
//		return;
//		var unitWidth = Math.ceil(rect.width/self.snapWidth)
		var rl = rects.length;
		ptrs = ptr.join() + ",links"; 
		for (var i = 0; i < rl; i++) {
			var rect = rects[i];
			//console.log(rect);
			//console.log("underground");
			var leftMostX = Math.floor(rect.x/this.snapWidth) * this.snapWidth
				//		leftMostX + (units*n) = rightMostX
				//		var unitHeight = Math.ceil(rect.height/self.snapHeight);
			var topMostY = Math.floor(rect.y/this.snapHeight) * this.snapHeight;
			var snaps = [];	
			//	console.log(rect);
			//	console.log("+____+");
			//	console.log(item);
			// needs to also manage the links 
			ptrsi = ptrs + ","+i;
			for (var x = leftMostX; x <= rect.right; x += this.snapWidth) {

				if (snapLookup[x] === undefined)
					snapLookup[x] = [];
				//console.log("fuck..you");
				for (var y = topMostY; y <= rect.bottom; y += this.snapHeight) {

					if (!snapLookup[x][y])
						snapLookup[x][y] = {};
					//var idx = self.snapLookUp[x][y].length;
					//if (this.snapLookup[x][y][ptrsi] === undefined) 
					//	this.snapLookup[x][y][ptrsi] = [];
	
					snapLookup[x][y][ptrsi] = {"type":"index", "ptr":ptr, "index":i};
									//var hash = item.__hid
					var snap = {"ptr":ptrsi, "x":x, "y":y}; 
					// '['+x+']['+y+']['+idx+']';
					// console.log(snap + " <<<<<< snap");
					//alert("test...");
					snaps.push(snap);
				}
			}
			//console.log(snaps);
			if (!gfxLookup[id].snaps) gfxLookup[id].snaps = [];
			gfxLookup[id].snaps.push(snaps);
		}
	//	return snaps; // the mouseup controller should reset this on move	
	},
	"setLabel":function(ptr) {
		// divide the box into components
		//console.log("cow cow cow cow");
		//console.log(ptr);
		var id = ptr[0];
		var rect = this.getLabel(ptr);
		snapLookup = snapSpace.prototype.snapLookup;
		//console.log(rect);
		//console.log("_________*&&&*___________"); 
//		return;
//		var unitWidth = Math.ceil(rect.width/self.snapWidth)
		var leftMostX = Math.floor(rect.x/this.snapWidth) * this.snapWidth
//		leftMostX + (units*n) = rightMostX
//		var unitHeight = Math.ceil(rect.height/self.snapHeight);
		var topMostY = Math.floor(rect.y/this.snapHeight) * this.snapHeight;
		var snaps = [];	
		//	console.log(rect);
		//	console.log("+____+");
		//	console.log(item);

		// needs to also manage the links
		ptrs = ptr.join() + ",label, 0"; 
		for (var x = leftMostX; x <= rect.right; x += this.snapWidth) {
			
			if (snapLookup[x] === undefined)
				snapLookup[x] = [];
			//console.log("fuck..you");
			for (var y = topMostY; y <= rect.bottom; y += this.snapHeight) {
				
				if (!snapLookup[x][y])
				       snapLookup[x][y] = {};
				//var idx = self.snapLookUp[x][y].length;
		//		if (this.snapLookup[x][y][ptrs] === undefined) 
		//			this.snapLookup[x][y][ptrs] = [];
				snapLookup[x][y][ptrs] = {"type":"label", "ptr":ptr};
					//var hash = item.__hid
				var snap = {"ptr":ptr, "x":x, "y":y}; 
				// '['+x+']['+y+']['+idx+']';
				// console.log(snap + " <<<<<< snap");
				//alert("test...");
				snaps.push(snap);
			}
		}
		//console.log(snaps);
		if (!gfxLookup[id].snaps) gfxLookup[id].snaps = [];
		gfxLookup[id].snaps.push(snaps);
		//return snaps; // the mouseup controller should reset this on move
	},
	// all code above this point should be moved to another class
*/
	"findRegged":function(e) {

		//console.log(e);/
		// quantize point
		//var pos = {};
		//if (e.offsetX) pos = e.offsetX; else pos = e.clientX - offset.x

		var pos = getPos(e); 

		var x = Math.floor(pos.x/this.snapWidth) * this.snapWidth;
		var y = Math.floor(pos.y/this.snapHeight) * this.snapHeight;
		
		//console.log(x+" "+y);

		// snap lookup has to also check for z axis to find the topmost element
		var sz = 0;
		if (snapLookup.hasOwnProperty(x))
			if (snapLookup[x].hasOwnProperty(y)) {
				// do something with the object
				//refine the object now...
				var slu = snapLookup[x][y];
				var ar = {};
				//console.log(x+" "+y);
				//for (var ii in this.snapLookup[x][y])
				//	console.log(ii);
			//	console.log("_______________________");
				for (var i in snapLookup[x][y]) {
					var a = snapLookup[x][y][i];

					//	console.log(i + "<<<");
					//		console.log(this.getLabel(o));
					//	console.log(pos.x+" "+pos.y);
					//console.log("____________________________________________________");
					//console.log(a);
					if (graphLookup[a[0]].hidden) continue;


					var ptri = i.split(",")

					var pli = ptri.pop();
					var plt = ptri.pop();

				 	var o = getObject(ptri, graphics);
					var rects = o.gfx.boundingBox;

					// this should fix all the bullshit in this event shit

					//console.log(plt);
					// could be reduced to getItem (ptri) without the pops here....
					// this code needs to be refactored to split up the object types and the event quantizer
					// something like snapSpace.prototype.getRect(ptri) and move all the link/label functionality to another class
				/*
					switch (plt) {
						case "links":
						       var rect = snapSpace.prototype.getLink(ptri, pli);
							//console.log(ptri+" "+pli);
						       //getPtrItemWithIndex_rect
						       break;
						case "label":
						       var rect = snapSpace.prototype.getLabel(ptri);
						       //getPtrLabel_rect
						       break;
					}
				*/
					//console.log(rect);
					//console.log(o);                                                 
					//for (var j =0; j < a.length; j++) {
					//var o = a[j];
					// this needs to be changed to reflect that we are getting specific ptr items
					// need to pull apart the last two elements

					//var rects = this.getItems({"ptr":o.ptr, "index":o.index})
					//	console.log("this is the rects__");
					//	console.log(rects);
					for (var jj in rects) {
						var rect = rects[jj];
						//console.log(rect);
						//console.log(pos.x+" "+pos.y);
						//console.log("******");	
						if (withinRect({"x":pos.x, "y":pos.y}, rect)) {
							//	console.log(j+" "+jj+"_marijuana_"+x+"_"+y+" "+i);
							//console.log(rect);
							//o.type = jj;
							//	console.log(o);	
							// 	the ptr hash needs to unique per each element...									// cycling through the ptrs doesnt work								
							var z = rect.z;
							if (!ar[z]) ar[z] = [];
							var idx = rect.index !== undefined ? rect.index : "";
							ar[z][i] = rect;
							//check properties .. is it visible?

							sz = z > sz ? z : sz;
							//	console.log(o.__hid);
							//	console.log(ar);
							//	console.log(o);
						}
					}
					//	}
				}
				return ar[sz];
			}
	},
			
	
	"overs":{},

	"mousemove":function(e) {
		//e.stopPropagation();
		//e.cancelBubble = true;
		//if (!moving)
		//console.log(e);
		//console.log(getPos(e));
		var regged = grid.findRegged(e);
		var go = Object.getOwnPropertyNames(grid.overs);
		if (go.length > 0 && !regged) {
			for (var gi =0; gi < go.length; gi++) {
				var goji = grid.overs[go[gi]];
				var uid = gfxLookup[goji.ptr[0]].uid;
				var evt = events[uid];
				evt.handleMouseOut(goji , e);
				//console.log("testing mouse out....");
			}
		}
			
		//console.log(regged) 
		//console.log("___");
		for (var g in grid.movers)  {

			var uid = gfxLookup[grid.movers[g].ptr[0]].uid
			var evt = events[uid]
			evt.handleMouseDrag(grid.movers[g], e);
		}


		for (var g in grid.overs) {
			//var obj = gfxLookup[grid.overs[g][0]];
			if (!regged) {
				delete grid.overs[g];
				continue;
			}
						

			if (!regged[g]) {
			//	console.log(g);
				//needs to be fixed for generic mouse outing...
				//console.log("testing mouse out.. HUH"+JSON.stringify(g));
			//	if (obj.handleMouseOut) {
					//console.log(grid.overs[g].type);
					//console.log("_____");
					var uid = gfxLookup[grid.overs[g].ptr[0]].uid ;
					var evt = events[uid];

					evt.handleMouseOut(grid.overs[g], e);
					//	}
				delete grid.overs[g];
			}
		}
		for (var r in regged) {
			//var gir = gfxLookup[regged[r][0]]
			// obvios issue is that the same ptr is being used for multiple stuff....
			if (!grid.overs[r]) {
				console.log("testing mouse enter..")
				console.log(regged[r].ptr);
				var uid = gfxLookup[regged[r].ptr[0]].uid ;
				var evt = events[uid];
				//if (gir.handleMouseEnter)
				//console.log(regged[r]);
				//console.log(regged[r].type);
				//if (regged[r].type == "label") 
				//console.log("*&**");
				//console.log(evt);
				evt.handleMouseEnter(grid.overs[r], e);	
			}
		}

		grid.overs = {};
		//console.log(regged);
		for (var r in regged) {
			grid.overs[r] = regged[r];
			//var rr = gfxLookup[regged[r][0]];
			//console.log("testing on mouse move"+regged[g]);

			//if (rr.handleMouseMove) {
			var uid = gfxLookup[regged[r].ptr[0]].uid ;
			var evt = events[uid];

			evt.handleMouseMove(regged[r], e)
			//}
		}
	},
	"moving":{},
	"movers":{},
	"mousedown":function(e) {
		moving=true;
		// need to log the x,y to check for mouseup click
		var pos = getPos(e);
		grid.mouseDownXY = pos;

		for (var g in grid.overs) {
		//	var gog = gfxLookup[grid.overs[g][0]];
			console.log("testing mouse down..");
			//if (self.overs[g].handleMouseDown)	
			//console.log(grid.overs[g]);
			//need to test whether or not to actually trigger a mouse move 
			//console.log(grid.overs[g]);

			var uid = gfxLookup[grid.overs[g].ptr[0]].uid ;
			//events should have a 'type' 
		
			var evt = events[uid];

			evt.handleMouseDown(grid.overs[g], e); //gog.handleMouseDown(e);
			grid.movers[g] = grid.overs[g];
		}
	},

	"mouseup":function(e) {
		// need to test if the item moved to detect a click 
		// also need to detect right click...
		var pos = getPos(e);
		var mc = Object.getOwnPropertyNames(grid.overs);
		for (var g in grid.movers) {
			//var gom = gfxLookup[grid.movers[g][0]];
			//console.log("testing mouse up.."+grid.overs[g]);
			//if (self.overs[g].__handlers.handleMouseUp) {
				//console.log("testing mouse up handler from __handlers");
			var uid = gfxLookup[grid.movers[g].ptr[0]].uid ;
			var evt = events[uid];
			if (Math.abs(grid.mouseDownXY.x - pos.x) < 4 && Math.abs(grid.mouseDownXY.y - pos.y) < 4) {
				//alert("click");
				evt.handleMouseClick(grid.movers[g], e);
			}
			//moveHandler.prototype should be sectioned off




			evt.handleMouseUp(grid.movers[g], e);
				//console.log(grid.movers[g].handleMouseUp)
			//}
		}
		if (mc.length == 0) {
			if (Math.abs(grid.mouseDownXY.x - pos.x) < 4 && Math.abs(grid.mouseDownXY.y - pos.y) < 4) {
					events["canvasClick"](e);
					//alert("clicked on blank canvas");
				}
	
		}
		grid.movers= {}
	},

	"setupHandlers":function(e) { 
		window.addEventListener("mousemove", snapSpace.prototype.mousemove, false);
		window.addEventListener("mousedown", snapSpace.prototype.mousedown, false);
		window.addEventListener("mouseup", snapSpace.prototype.mouseup, false);
	},
	"updateSnapObject":function(id) {
		//var id = ptr[0];
		var gl = gfxLookup[id];
		var sl = gl.snaps.length;
		snapLookup = snapSpace.prototype.snapLookup;

		for (var i=0; i < sl; i++) {
			var gls = gl.snaps[i];
			var glsl = gls.length;
			for (var j = 0; j < glsl; j++) {
				var glsj = gls[j];
				//console.log(gls.x+" "+gls.y+" "+gls.ptr);
				delete snapLookup[glsj.x][glsj.y][glsj.ptr]
			}
		}
		//console.log("____ggggllll_____");
		//console.log(gl) 
		delete gl.snaps;
		//grid.setItem(ptr);
	
		gl.regAll();			
	}

}
moveHandler = new moveHandler();
grid = new snapSpace();
//alert("test..");


//move handler code to new file 



function userEvents() {
}


userEvents.prototype = {
	"handleMouseEnter": function(ptr, e) {

	}, 
	"handleMouseDown": function(ptr, e) {


	},
	"handleMouseDrag": function(ptr, e) {
	},
	
	"handleMouseMove": function(ptr, e) {

	},
	"handleMouseClick": function(ptr, e) {

	},
	"handleMouseOut": function(ptr, e) {

	},
	"handleMouseUp": function(ptr, e) {
	},
	"handleMouseCanvasClick": function(ptr, e) {
		alert("test...");
	}
	
}

// should be moved into a seperate file
function contextEventHandler() {

}

contextEventHandler.prototype = {

	"handleMouseCanvasClick": function(ptr, e) {

	},
	"handleMouseClick": function(ptr, e) {
		//alert("test...");
		//console.log(ptr);
		var o = getObject(ptr.ptr, graphics);
//		console.log(o)	
		switch (o.ptr) {
			case "[expand]": 
				
			break;
			case "[hide]":
				// set parent to
				cm.hideLastPTR(); 
			break;
			case "[addChild]":
			break;
			case "[addSibling]":
			break;
			case "[setType][db]":
			break;
			case "[setType][json]":
			break;
		}
		console.log("handling mouse click on "+ptr);
		console.log(ptr);
		cm.checkContextState(e);
		////console.log("-----");
		//console.log(o.ptr);

		// determine what element we just clicked on ...., return the node value
	}

}

extend(userEvents, contextEventHandler);
//console.log(contextEventHandler.prototype);

function moveHandler() {
/*
	var self = this;

	this.moveStack = [];	
	var mover = this;
	//mover.offset;
	self.isMoving = false;
	self.offset = false;
	self.draggable = true;
	
	self.test = function () {
		alert("hi");
	}
	//alert(JSON.stringify(obj));
	//if (!obj) alert("huh");
	//alert(self.obj);
		

	//	console.log(e)
	//var moveStack = self.moveStack;

	//rather than use mousedown layer on
	//we should check snap to coordinates
	//document.addEvoentListener('onmousemo') 
*/
}

// todo manage ptr to events //
// then refresh ptr event // 

var handlerData = {};
moveHandler.prototype =  {
	"handleMouseEnter": function(ptr, e) {


	},


	"handleMouseDown": function(ptr, e) {
		//console.log(self.obj);
		// right now, this code is specific for moving the shit around
		// needs to test type

		ptr = ptr.ptr;
		//console.log(ptr);
		//console.log("____");
		var id = ptr[0];
		//todo 
		/*
		gfxLookup[id].model.draggable 
			if (!self.draggable) {
				console.log("xxx");
				return;
			}
		*/
		if (!handlerData.offset) {
			//console.log("*)()(())()(*");
			//getmouseposition
			handlerData.ogup = getPos(e);
			var pos = getPos(e);
			//console.log(pos.x+" "+abs.x);
			//console.log(id);
			var abs = graphics[id].model.loc;

			handlerData.offset = {"x": pos.x - abs.x, "y": pos.y - abs.y};
			//console.log("offset: "+self.offset);
		}
		//self.dbo.layer.draggable(false);
		//	var dom = stage.getDOM();
		//	dom.addEventListener('mousemove', self.handleMove, true);
		//	dom.addEventListener('mouseup', self.handleMouseUp, true);
		//	dom.addEventListener('click', self.handleClick, true);
		//maybe self clean?
		//
		//	for (var g in self.moveStack) {
		//		dom.addEventListener('mousemove', self.moveStack[g], true);
		//	}
		//
		//beginmove
	},
	// should probably be a new one
	//mover.layer.on("mousemove",
	"handleMouseMove": function(ptr, e) {

	},
	"handleMouseDrag": function(ptr, e){
		//console.log(self.draggable);
		//	console.log("xx");

		/*
		if (!handler.draggable) {
			//	console.log("uu");
			return;
		}`
		*/
		//	var pos = stage.getUserPosition();
		ptr = ptr.ptr; // 
		var gfo = gfxLookup[ptr[0]];
		//console.log(pos.x);
		if (handlerData.offset) {
			var pos = getPos(e);

			if ((pos.x - handlerData.offset.x) <= 0) {

				//gfo.setX(0);
				//gfo.putToScreen();
				//	self.root.stopDrag();
			//	return;
			}

			if ((pos.y - handlerData.offset.y)  <= 0) {
				//gfo.setY(0);
				//self.layer.draw();
				//	self.root.stopDrag();
			//	return;
			}

			//	console.log("________________");
			gfo.setXY( pos.x - handlerData.offset.x, pos.y - handlerData.offset.y)
				//.layer.draw();
		}
	},

	//mover.layer.on("mouseup", 
	"handleMouseUp":function(ptr, e) {
		ptr = ptr.ptr;
		handlerData.offset = false;
		//alert('testtttt..');	
		//		console.log("handleMouseUp");
		//		var dom = stage.getDOM();
		//		dom.removeEventListener('mousemove', mover.handleMove, true);
		//		dom.removeEventListener('mouseup', mover.handleMouseUp, true);
		//for (var g in self.moveStack) {
		//	dom.removeEventListener('mousemove', self.moveStack[g], true);
		//	console.log("testing move listeners........");
		//}

		//self.mover = false;

		var gfo = gfxLookup[ptr[0]]; // perhaps gtfo is a better variable name

		var pos = getPos(e); //stage.getUserPosition();
		//alert(self.obj);
		//var abs = self.obj.layer.getAbsolutePosition();
		//	console.log(pos.x+" "+abs.x);
		var test = {};
		test.x = pos.x;
		test.y = pos.y;
		//	console.log(pos);
		//	console.log("-----");
		//	console.log(self.ogup);
				//e.stopImmediatePropagation();
		//endmove
		handlerData.offset = false;
		// should check draggability and then update the event grid
		// assume everything is draggable for now.......
		var id = ptr[0];
		/*
		var gl = gfxLookup[id];
		var sl = gl.snaps.length;
		for (var i=0; i < sl; i++) {
			var gls = gl.snaps[i];
			var glsl = gls.length;
			for (var j = 0; j < glsl; j++) {
				var glsj = gls[j];
				//console.log(gls.x+" "+gls.y+" "+gls.ptr);
				delete grid.snapLookup[glsj.x][glsj.y][glsj.ptr]
			}
		}
		console.log("____ggggllll_____");
		console.log(gl) 
		delete gl.snaps;
		*/
		snapSpace.prototype.updateSnapObject(id);
		//grid.setItem(ptr);
	
		//gl.regAll();	
			

		if (gfo.mouseUp) 
			gfo.mouseUp(ptr, e);
	},

	"handleMouseOut": function(ptr, e) {
		ptr = ptr.ptr;
		var gfo = gfxLookup[ptr[0]];
		if (gfo.mouseOut) 
			gfo.mouseOut(ptr, e);
	}

	//mover.layer.on("click", mover.onclick());
/*
	"handleClick": function(ptr) { 
lki		//	console.log("handleClick");
		//	stage.getDOM().removeEventListener('mousemove', mover.handleMove, true);
		//	stage.getDOM().removeEventListener('mouseup', mover.handleUp, true);
		//	stage.getDOM().addEventListener('click', mover.handleClick, true);
		self.offset = false;
	},
	"stopDrag": function(ptr) {
		//	stage.getDOM().removeEventListener('mousemove', self.handleMove, true);
		//		stage.getDOM().removeEventListener('mouseup', self.handleUp, true);
		//		stage.getDOM().addEventListener('click', self.handleClick, true);
		//		self.offset = false;
		self.still = true;
	}
*/
}


extend(userEvents, moveHandler);



function nodeEventHandler() {


}

nodeEventHandler.prototype = {
	"handleMouseClick":function(ptr, e) {
		console.log(ptr);
		if (ptr.type == "label") {
		//	alert(ptr+" "+e);
			cm.contextMenu(ptr, e);
		}
		if (ptr.type == "index") {
			
		}
		//document
	},

} 


extend(moveHandler, nodeEventHandler);

function updateSnapObject() {


}



/*
handler = new moveHandler();
*/
